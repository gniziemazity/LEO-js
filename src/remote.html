<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>LEO Remote</title>
		<link rel="icon" href="icon.ico" type="image/x-icon" />
		<link rel="stylesheet" href="styles.css" />
	</head>
	<body class="mobile-view">
		<div id="mobile-header">
			<div class="header-main-row">
				<button
					id="toggleBtn"
					class="interaction-btn btn-start"
					onclick="toggleActive()"
				>
					‚ñ∂Ô∏é
				</button>
				<div id="interactionButtons">
					<button
						class="interaction-btn btn-student-question"
						onclick="handleInteractionBtn('student-question')"
						title="Student Question"
					>
						<span class="dark-emoji">‚ùì</span>
					</button>
					<button
						class="interaction-btn btn-help"
						onclick="handleInteractionBtn('providing-help')"
						title="Providing Help"
					>
						<span class="dark-emoji">ü§ù</span>
					</button>
					<button
						id="touchpadBtn"
						class="interaction-btn btn-touchpad"
						onclick="toggleTouchpad()"
						title="Toggle Touchpad"
					>
						<span class="dark-emoji">üñ±Ô∏è</span>
					</button>
				</div>
				<div id="timerSection">
					<button
						id="timerStartBtn"
						class="timer-btn"
						onclick="startTimer()"
						title="Start Timer"
					>
						‚è±Ô∏è
					</button>
					<div id="timerControls" class="timer-controls">
						<button
							class="timer-btn"
							onclick="adjustTimer(-10)"
							title="-10 min"
						>
							‚Äì
						</button>
						<span
							id="timerDisplay"
							class="timer-display"
							onclick="stopTimer()"
							title="Click to stop"
						></span>
						<button
							class="timer-btn"
							onclick="adjustTimer(10)"
							title="+10 min"
						>
							+
						</button>
					</div>
				</div>
			</div>
			<div class="progress-bar" id="progressBar"></div>
		</div>

		<div id="lesson-container">
			<div class="empty-state">Connecting to LEO...</div>
		</div>

		<!-- Touchpad overlay -->
		<div id="touchpadOverlay" class="touchpad-overlay">
			<div class="touchpad-toolbar">
				<button
					id="modeBtn"
					class="touchpad-tb-btn"
					onclick="toggleTouchpadMode()"
				>
					üñ±Ô∏è Mouse
				</button>
				<button
					class="touchpad-tb-btn touchpad-close-btn"
					onclick="toggleTouchpad()"
				>
					‚úï
				</button>
			</div>
		</div>

		<div id="questionOverlay" class="overlay">
			<div class="q-modal">
				<div class="q-question-text" id="qText"></div>
				<div class="q-subtitle" id="qSubtitle">Who answered?</div>
				<div class="q-grid" id="qGrid"></div>
				<div class="q-answered-row" id="qAnsweredRow">
					<span id="qAnsweredText"></span>
					<div class="q-close-bar">
						<div class="q-close-bar-fill" id="qCloseBarFill"></div>
					</div>
				</div>
			</div>
		</div>

		<!-- Student interaction overlay (student-question / providing-help) -->
		<div id="interactionOverlay" class="overlay">
			<div class="i-modal" id="iModal">
				<div class="i-title" id="iTitle">Select student</div>
				<input
					type="text"
					class="i-question-input"
					id="iQuestionInput"
					placeholder="Type the question here..."
					style="display: none"
				/>
				<div class="i-grid" id="iGrid"></div>
				<button class="i-cancel-btn" onclick="closeInteractionOverlay()">
					Cancel
				</button>
			</div>
		</div>

		<script>
			let ws = null;
			let currentSettings = null;
			let isActive = false;
			let currentStudents = [];
			let pendingInteraction = null;
			let autoCloseTimer = null;

			document.addEventListener("click", function goFS() {
				const el = document.documentElement;
				const rfs =
					el.requestFullscreen ||
					el.webkitRequestFullscreen ||
					el.msRequestFullscreen;
				if (rfs) rfs.call(el).catch(() => {});
				document.removeEventListener("click", goFS);
			});

			let touchpadActive = false;
			let touchStartX = 0;
			let touchStartY = 0;
			let lastSendTime = 0;
			let MOUSE_SENSITIVITY = 3;
			let SCROLL_SENSITIVITY = 3;
			const SEND_THROTTLE_MS = 30;
			let isDragging = false;
			let oneFingerMoved = false;
			let tapTime = 0;
			let tapTimeout = null;
			let twoFingerStartX = 0;
			let twoFingerTapStart = 0;
			let twoFingerMoved = false;
			let wasTwoFinger = false; // tracks staggered finger release
			let touchpadMode = "mouse"; // "mouse" or "keyboard"
			let scrollAnchorId = null; // touch identifier for scroll tracking
			let scrollAccum = 0; // accumulated fractional scroll

			// Scroll momentum state
			let scrollVelocity = 0;
			let momentumAnimId = null;
			const MOMENTUM_FRICTION = 0.9;
			const MOMENTUM_MIN_VEL = 0.5;
			const VELOCITY_SMOOTHING = 0.4;

			function startScrollMomentum() {
				if (momentumAnimId) cancelAnimationFrame(momentumAnimId);
				function step() {
					scrollVelocity *= MOMENTUM_FRICTION;
					if (Math.abs(scrollVelocity) < MOMENTUM_MIN_VEL) {
						scrollVelocity = 0;
						momentumAnimId = null;
						return;
					}
					scrollAccum += scrollVelocity;
					const toSend = Math.trunc(scrollAccum);
					if (toSend !== 0) {
						scrollAccum -= toSend;
						sendMessage("mouse-scroll", { dy: toSend });
					}
					momentumAnimId = requestAnimationFrame(step);
				}
				momentumAnimId = requestAnimationFrame(step);
			}

			function stopScrollMomentum() {
				if (momentumAnimId) {
					cancelAnimationFrame(momentumAnimId);
					momentumAnimId = null;
				}
				scrollVelocity = 0;
				scrollAccum = 0;
			}

			// 90¬∞ CCW rotation: screen dx,dy -> cursor dy,-dx
			function rotateCCW(dx, dy) {
				return { dx: dy, dy: -dx };
			}

			// Wake Lock
			let wakeLock = null;

			const AUTO_CLOSE_MS = 3000;

			function getBlockSubtype(text) {
				const t = text.trim();
				if (t.startsWith("‚ùì")) return "question-comment";
				if (t.startsWith("üñºÔ∏è")) return "image-comment";
				return null;
			}

			function buildSettingsCSS(settings) {
				return `
					body { font-size: ${settings.fontSize}px; }
					.comment-block, .code-block { color: ${settings.colors.textColor}; }
					.comment-block { background: ${settings.colors.commentNormal}; }
					.comment-block.question-comment { background: ${settings.colors.questionCommentColor}; }
					.comment-block.image-comment { background: ${settings.colors.imageBlockColor}; }
					.comment-block.active-comment {
						background: ${settings.colors.commentActive};
						color: ${settings.colors.commentActiveText};
					}
					.char.cursor { background: ${settings.colors.cursor}; }
				`;
			}

			function formatAnsweredText(name) {
				return name ? `‚úÖ Answered by ${name}` : "‚úÖ Answered";
			}

			function createCharSpan(char, stepIndex) {
				let el = document.createElement("span");
				el.className = "char";
				if (char === "\n") el = document.createElement("br");
				else if (char === " ") el.innerHTML = "&nbsp;";
				else el.textContent = char;
				el.dataset.stepIndex = stepIndex;
				return el;
			}

			const elements = {
				timerDisplay: document.getElementById("timerDisplay"),
				timerSection: document.getElementById("timerSection"),
				timerStartBtn: document.getElementById("timerStartBtn"),
				timerControls: document.getElementById("timerControls"),
				progressBar: document.getElementById("progressBar"),
				lessonContainer: document.getElementById("lesson-container"),
				toggleBtn: document.getElementById("toggleBtn"),
				touchpadBtn: document.getElementById("touchpadBtn"),
				touchpadOverlay: document.getElementById("touchpadOverlay"),
			};

			// ‚îÄ‚îÄ Timer ‚îÄ‚îÄ

			function startTimer() {
				sendMessage("timer-start", {});
			}

			function stopTimer() {
				sendMessage("timer-stop", {});
			}

			function adjustTimer(minutes) {
				sendMessage("timer-adjust", { minutes });
			}

			function showTimerRunning(totalSecs) {
				elements.timerStartBtn.classList.add("hidden");
				elements.timerControls.classList.add("show");
				const h = Math.floor(totalSecs / 3600);
				const m = Math.floor((totalSecs % 3600) / 60);
				const s = totalSecs % 60;
				elements.timerDisplay.textContent =
					h > 0
						? `${h}:${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`
						: `${m}:${s.toString().padStart(2, "0")}`;
			}

			function showTimerStopped() {
				elements.timerDisplay.textContent = "";
				elements.timerControls.classList.remove("show");
				elements.timerStartBtn.classList.remove("hidden");
			}

			// ‚îÄ‚îÄ Touchpad ‚îÄ‚îÄ

			function toggleTouchpad() {
				touchpadActive = !touchpadActive;
				elements.touchpadOverlay.classList.toggle("active", touchpadActive);
				elements.touchpadBtn.classList.toggle(
					"btn-touchpad-active",
					touchpadActive,
				);
				if (!touchpadActive && isDragging) {
					isDragging = false;
					sendMessage("mouse-drag-end", {});
					elements.touchpadOverlay.classList.remove("dragging");
				}
			}

			function toggleTouchpadMode() {
				const modeBtn = document.getElementById("modeBtn");
				if (touchpadMode === "mouse") {
					touchpadMode = "keyboard";
					modeBtn.textContent = "‚å®Ô∏è Keyboard";
					elements.touchpadOverlay.classList.add("keyboard-mode");
				} else {
					touchpadMode = "mouse";
					modeBtn.textContent = "üñ±Ô∏è Mouse";
					elements.touchpadOverlay.classList.remove("keyboard-mode");
				}
			}

			(function setupTouchpad() {
				const overlay = document.getElementById("touchpadOverlay");
				const TAP_MAX_MS = 200;
				const DOUBLE_TAP_GAP_MS = 300;
				const MOVE_THRESHOLD = 8;
				let touchDownTime = 0;
				let touchDownX = 0;
				let touchDownY = 0;

				overlay.addEventListener(
					"touchstart",
					(e) => {
						if (e.target.closest(".touchpad-toolbar")) return;
						e.preventDefault();

						if (touchpadMode === "keyboard") {
							sendMessage("remote-key-press", {});
							return;
						}

						if (e.touches.length === 2) {
							const anchor = e.touches[0];
							scrollAnchorId = anchor.identifier;
							twoFingerStartX = anchor.clientX;
							twoFingerTapStart = Date.now();
							twoFingerMoved = false;
							wasTwoFinger = true;
							stopScrollMomentum();
							return;
						}

						const t = e.touches[0];
						touchStartX = t.clientX;
						touchStartY = t.clientY;
						touchDownX = t.clientX;
						touchDownY = t.clientY;
						touchDownTime = Date.now();
						oneFingerMoved = false;

						const gap = touchDownTime - tapTime;
						if (tapTime > 0 && gap < DOUBLE_TAP_GAP_MS) {
							if (tapTimeout) {
								clearTimeout(tapTimeout);
								tapTimeout = null;
							}
							isDragging = true;
							sendMessage("mouse-drag-start", {});
							overlay.classList.add("dragging");
							tapTime = 0;
						}
					},
					{ passive: false },
				);

				overlay.addEventListener(
					"touchmove",
					(e) => {
						e.preventDefault();
						if (touchpadMode === "keyboard") return;
						const now = Date.now();
						if (now - lastSendTime < SEND_THROTTLE_MS) return;
						lastSendTime = now;

						if (e.touches.length === 2) {
							let anchor = null;
							for (let i = 0; i < e.touches.length; i++) {
								if (e.touches[i].identifier === scrollAnchorId) {
									anchor = e.touches[i];
									break;
								}
							}
							if (!anchor) return;
							const dx =
								(anchor.clientX - twoFingerStartX) * SCROLL_SENSITIVITY;
							twoFingerStartX = anchor.clientX;
							const scrollDy = -dx;
							scrollAccum += scrollDy;
							scrollVelocity =
								scrollVelocity * (1 - VELOCITY_SMOOTHING) +
								scrollDy * VELOCITY_SMOOTHING;
							const toSend = Math.trunc(scrollAccum);
							if (toSend !== 0) {
								twoFingerMoved = true;
								scrollAccum -= toSend;
								sendMessage("mouse-scroll", { dy: toSend });
							}
						} else if (e.touches.length === 1) {
							if (wasTwoFinger) return;

							const t = e.touches[0];
							const totalDx = Math.abs(t.clientX - touchDownX);
							const totalDy = Math.abs(t.clientY - touchDownY);
							if (totalDx > MOVE_THRESHOLD || totalDy > MOVE_THRESHOLD) {
								oneFingerMoved = true;
							}
							const screenDx =
								(t.clientX - touchStartX) * MOUSE_SENSITIVITY;
							const screenDy =
								(t.clientY - touchStartY) * MOUSE_SENSITIVITY;
							touchStartX = t.clientX;
							touchStartY = t.clientY;
							const rotated = rotateCCW(screenDx, screenDy);
							if (
								Math.abs(rotated.dx) > 0.5 ||
								Math.abs(rotated.dy) > 0.5
							) {
								sendMessage("mouse-move", {
									dx: Math.round(rotated.dx),
									dy: Math.round(rotated.dy),
								});
							}
						}
					},
					{ passive: false },
				);

				overlay.addEventListener(
					"touchend",
					(e) => {
						if (e.target.closest(".touchpad-toolbar")) return;
						e.preventDefault();

						if (touchpadMode === "keyboard") return;

						if (e.touches.length === 0 && twoFingerTapStart > 0) {
							const elapsed = Date.now() - twoFingerTapStart;
							if (!twoFingerMoved && elapsed < 300) {
								sendMessage("mouse-click", { button: "right" });
							} else if (
								twoFingerMoved &&
								Math.abs(scrollVelocity) > MOMENTUM_MIN_VEL
							) {
								startScrollMomentum();
							}
							twoFingerTapStart = 0;
							wasTwoFinger = false;
							return;
						}

						if (e.touches.length > 0 && wasTwoFinger) return;
						if (e.touches.length > 0) return;

						if (wasTwoFinger) {
							wasTwoFinger = false;
							return;
						}

						if (isDragging) {
							isDragging = false;
							sendMessage("mouse-drag-end", {});
							overlay.classList.remove("dragging");
							return;
						}

						const elapsed = Date.now() - touchDownTime;
						if (!oneFingerMoved && elapsed < TAP_MAX_MS) {
							tapTime = Date.now();
							tapTimeout = setTimeout(() => {
								sendMessage("mouse-click", { button: "left" });
								tapTime = 0;
								tapTimeout = null;
							}, DOUBLE_TAP_GAP_MS);
						}
					},
					{ passive: false },
				);
			})();

			async function requestWakeLock() {
				try {
					if ("wakeLock" in navigator) {
						wakeLock = await navigator.wakeLock.request("screen");
						wakeLock.addEventListener("release", () => {
							wakeLock = null;
						});
					}
				} catch (e) {
					/* wake lock not supported or denied */
				}
			}

			document.addEventListener("visibilitychange", () => {
				if (document.visibilityState === "visible") {
					requestWakeLock();
					// reconnect immediately if ws is closed
					if (!ws || ws.readyState !== WebSocket.OPEN) connect();
				}
			});

			function connect() {
				const host = window.location.host;
				const protocol =
					window.location.protocol === "https:" ? "wss:" : "ws:";
				if (ws) {
					try {
						ws.close();
					} catch (e) {}
				}
				ws = new WebSocket(`${protocol}//${host}`);
				ws.onopen = () => requestWakeLock();
				ws.onmessage = (event) => handleMessage(JSON.parse(event.data));
				ws.onclose = () => {
					ws = null;
					setTimeout(connect, 2000);
				};
			}

			function handleMessage(message) {
				const { type, data } = message;
				switch (type) {
					case "state":
						updateAllState(data);
						break;
					case "lesson-data":
						updateLessonData(data);
						break;
					case "cursor":
						updateCursor(data);
						break;
					case "progress":
						updateProgress(data);
						break;
					case "settings":
						applySettings(data);
						break;
					case "active":
						updateActiveState(data.isActive);
						break;
					case "students":
						currentStudents = data.students || [];
						break;
					case "question-started":
						showQuestionOverlay(
							data.question,
							data.students,
							data.bgColor,
						);
						break;
					case "question-ended":
						hideQuestionOverlay();
						break;
					case "timer-tick":
						showTimerRunning(data.timeRemaining);
						break;
					case "timer-stopped":
						showTimerStopped();
						break;
				}
			}

			function updateAllState(state) {
				updateProgress(state);
				if (state.isActive !== undefined) updateActiveState(state.isActive);
				if (state.settings) applySettings(state.settings);
				if (state.lessonData) updateLessonData(state.lessonData);
				if (state.currentStep !== undefined)
					updateCursor({ currentStep: state.currentStep });
				if (state.students) currentStudents = state.students;
				if (state.activeQuestion)
					showQuestionOverlay(
						state.activeQuestion,
						state.students || [],
						null,
					);
				if (state.timeRemaining != null)
					showTimerRunning(state.timeRemaining);
				else showTimerStopped();
			}

			function updateActiveState(active) {
				isActive = active;
				elements.toggleBtn.textContent = active ? "‚ùö‚ùö" : "‚ñ∂Ô∏é";
				elements.toggleBtn.classList.toggle("btn-stop", active);
				elements.toggleBtn.classList.toggle("btn-start", !active);
				elements.toggleBtn.classList.add("interaction-btn");
			}

			function applySettings(settings) {
				currentSettings = settings;
				const id = "dynamic-settings-styles";
				let s = document.getElementById(id);
				if (!s) {
					s = document.createElement("style");
					s.id = id;
					document.head.appendChild(s);
				}
				s.textContent = buildSettingsCSS(settings);

				if (settings.touchpadSensitivity != null) {
					MOUSE_SENSITIVITY = settings.touchpadSensitivity;
					SCROLL_SENSITIVITY = settings.touchpadSensitivity * 0.67;
				}
			}

			function updateLessonData(data) {
				const { blocks } = data;
				elements.lessonContainer.innerHTML = "";
				if (!blocks || !blocks.length) return;
				let ctr = 0;
				blocks.forEach((block) => {
					const div = document.createElement("div");
					div.className = `block ${block.type}-block`;
					if (block.type === "comment") {
						div.innerText = block.text;
						const subtype = getBlockSubtype(block.text);
						if (subtype) div.classList.add(subtype);
						div.dataset.stepIndex = ctr++;
						div.onclick = handleBlockClick;
					} else if (block.type === "code") {
						for (const char of block.text) {
							div.appendChild(createCharSpan(char, ctr++));
						}
						div.dataset.stepIndex = ctr++;
						div.onclick = handleCodeClick;
					}
					elements.lessonContainer.appendChild(div);
				});
			}

			function updateCursor(data) {
				const { currentStep } = data;
				document
					.querySelectorAll(".cursor, .consumed, .active-comment")
					.forEach((el) => {
						el.classList.remove("cursor", "consumed", "active-comment");
					});
				document.querySelectorAll("[data-step-index]").forEach((el) => {
					const idx = parseInt(el.dataset.stepIndex);
					if (idx < currentStep) {
						el.classList.add("consumed");
					} else if (idx === currentStep) {
						el.classList.add(
							el.classList.contains("char")
								? "cursor"
								: "active-comment",
						);
						el.scrollIntoView({ behavior: "smooth", block: "center" });
					}
				});
			}

			function updateProgress(data) {
				if (data.progress !== undefined)
					elements.progressBar.style.width = `${data.progress}%`;
			}

			function showQuestionOverlay(question, students, bgColor) {
				clearAutoCloseTimer();

				document.getElementById("qText").textContent = question;

				const overlay = document.getElementById("questionOverlay");
				overlay.style.background = bgColor
					? hexToRgba(bgColor, 0.94)
					: "rgba(0,0,0,0.78)";

				const grid = document.getElementById("qGrid");
				const subtitle = document.getElementById("qSubtitle");
				const answered = document.getElementById("qAnsweredRow");
				grid.innerHTML = "";
				grid.style.display = "flex";
				subtitle.style.display = "";
				answered.style.display = "none";
				document.getElementById("qCloseBarFill").style.transition = "none";
				document.getElementById("qCloseBarFill").style.width = "0%";

				const list = students && students.length ? students : null;

				if (list) {
					subtitle.textContent = "Who answered?";
					list.forEach((name) => {
						const btn = document.createElement("button");
						btn.className = "q-student-btn";
						btn.textContent = name;
						btn.onclick = () => onStudentAnswered(name);
						grid.appendChild(btn);
					});
				} else {
					subtitle.textContent = "";
					const btn = document.createElement("button");
					btn.className = "q-student-btn";
					btn.style.cssText = "width:100%;margin-bottom:4px";
					btn.textContent = "‚úÖ Answered";
					btn.onclick = () => onStudentAnswered(null);
					grid.appendChild(btn);
				}

				overlay.classList.add("active");
			}

			function onStudentAnswered(name) {
				sendMessage("student-answered", { studentName: name });

				document.getElementById("qGrid").style.display = "none";
				document.getElementById("qSubtitle").style.display = "none";

				const answeredRow = document.getElementById("qAnsweredRow");
				const answeredText = document.getElementById("qAnsweredText");
				answeredText.textContent = formatAnsweredText(name);
				answeredRow.style.display = "flex";

				const fill = document.getElementById("qCloseBarFill");
				fill.style.transition = "none";
				fill.style.width = "0%";
				requestAnimationFrame(() => {
					requestAnimationFrame(() => {
						fill.style.transition = `width ${AUTO_CLOSE_MS}ms linear`;
						fill.style.width = "100%";
					});
				});

				autoCloseTimer = setTimeout(
					() => hideQuestionOverlay(),
					AUTO_CLOSE_MS,
				);
			}

			function hideQuestionOverlay() {
				clearAutoCloseTimer();
				document
					.getElementById("questionOverlay")
					.classList.remove("active");
			}

			function clearAutoCloseTimer() {
				if (autoCloseTimer) {
					clearTimeout(autoCloseTimer);
					autoCloseTimer = null;
				}
			}

			let interactionOpenedAt = null;

			function handleInteractionBtn(interactionType) {
				if (currentStudents.length > 0) {
					pendingInteraction = interactionType;
					interactionOpenedAt = Date.now();
					const isQuestion = interactionType === "student-question";
					const title = isQuestion
						? "‚ùì Who asked a question?"
						: "ü§ù Who needs help?";
					showInteractionOverlay(title, currentStudents, interactionType);
				} else {
					sendMessage("interaction", { interactionType });
				}
			}

			function showInteractionOverlay(title, students, type) {
				const modal = document.getElementById("iModal");
				modal.className = "i-modal";
				if (type === "student-question") {
					modal.classList.add("type-student-question");
					document.getElementById("interactionOverlay").style.background =
						"rgba(120,50,0,0.82)";
				} else {
					modal.classList.add("type-providing-help");
					document.getElementById("interactionOverlay").style.background =
						"rgba(0,80,30,0.82)";
				}

				document.getElementById("iTitle").textContent = title;

				const questionInput = document.getElementById("iQuestionInput");
				if (type === "student-question") {
					questionInput.style.display = "block";
					questionInput.value = "";
					setTimeout(() => questionInput.focus(), 100);
				} else {
					questionInput.style.display = "none";
				}

				const grid = document.getElementById("iGrid");
				grid.innerHTML = "";
				students.forEach((name) => {
					const btn = document.createElement("button");
					btn.className = "i-student-btn";
					btn.textContent = name;
					btn.onclick = () => {
						const qText =
							type === "student-question"
								? questionInput.value.trim()
								: null;
						const msgData = {
							interactionType: pendingInteraction,
							studentName: name,
							openedAt: interactionOpenedAt,
							closedAt: Date.now(),
						};
						if (qText) msgData.questionText = qText;
						sendMessage("student-interaction", msgData);
						closeInteractionOverlay();
					};
					grid.appendChild(btn);
				});
				document
					.getElementById("interactionOverlay")
					.classList.add("active");
			}

			function closeInteractionOverlay() {
				document
					.getElementById("interactionOverlay")
					.classList.remove("active");
				document.getElementById("iQuestionInput").style.display = "none";
				pendingInteraction = null;
			}

			function hexToRgba(hex, alpha) {
				const r = parseInt(hex.slice(1, 3), 16);
				const g = parseInt(hex.slice(3, 5), 16);
				const b = parseInt(hex.slice(5, 7), 16);
				return `rgba(${r},${g},${b},${alpha})`;
			}

			function sendMessage(type, data) {
				if (ws && ws.readyState === WebSocket.OPEN)
					ws.send(JSON.stringify({ type, data }));
			}

			function handleCodeClick(e) {
				if (!isActive) return;
				const span = e.target.closest(".char");
				if (span)
					sendMessage("jump-to", {
						stepIndex: parseInt(span.dataset.stepIndex),
					});
			}

			function handleBlockClick(e) {
				if (!isActive) return;
				const div = e.target.closest(".block");
				if (div && div.dataset.stepIndex)
					sendMessage("jump-to", {
						stepIndex: parseInt(div.dataset.stepIndex),
					});
			}

			function toggleActive() {
				sendMessage("toggle-active", {});
			}

			setTimeout(connect, 500);
		</script>
	</body>
</html>
